# 日记

## 如何用 AI 辅助开发

- instruction prompt 指令提示

```bash
1，首先说明意图；
2，然后是针对不同情况的处理方案，每个方案有每个方案的实时步骤；
3，再然后是着重强调的一些规则，比如针对 hooks 写单测时应该使用 @testing-library/react 而不应该再使用已被废弃的 @testing-library/react-hooks ，比如组件与hooks 如何命名，单测文件放哪里等等；
4，最后是提示它当前的工作目录 (Working Set) 是目前需要处理的文件。
```

## grafana

- mingrenchen@grafana.net

## vue3

- reactive

```bash
# 对一个已存在的代理对象调用 reactive() 会返回其本身
console.log(reactive(proxy) === proxy) // true
# 响应式对象内的嵌套对象依然是代理
const proxy = reactive({})
const raw = {}
proxy.nested = raw
console.log(proxy.nested === raw) // false
```

- 写代码时先考虑使用`reactive`能否实现，否则使用`ref`
- 解构`ref`、`reactive`将失去响应式
- props 可以解构：`const { foo } = defineProps(['foo'])`
- 写代码时先考虑是否需要计算缓存，需要则使用`computed`，不需要则使用`方法`
- watch 不能侦听响应式对象的属性值，可侦听`响应式对象、getter函数、多个来源组成的数组`
- `watchEffect()` 允许我们自动跟踪回调的响应式依赖，且仅会在其`同步`执行期间，才追踪依赖，所以无法追踪到 await 后的响应式变量
- `model、computed、props`都是`ref`

- `组件事件` - 假如你想改变 props 的值并同步给父组件

```bash
<script setup>
const emit = defineEmits(['inFocus', 'submit'])
function buttonClick() {
  emit('submit')
}
</script>
```

## TSDB 操作

- taos;
- show databases;
- use idmp;
- show stables;
- show tables;

## echarts 示例[status-history]

```js
var data = []
var dataCount = 10
var startTime = +new Date()
var categories = ['categoryA', 'categoryB', 'categoryC']
var types = [
  { name: 'JS Heap', color: '#7b9ce1' },
  { name: 'Documents', color: '#bd6d6c' },
  { name: 'Nodes', color: '#75d874' },
  { name: 'Listeners', color: '#e0bc78' },
  { name: 'GPU Memory', color: '#dc77dc' },
  { name: 'GPU', color: '#72b362' }
]
// Generate mock data
categories.forEach(function (category, index) {
  var baseTime = startTime
  for (var i = 0; i < dataCount; i++) {
    var typeItem = types[Math.round(Math.random() * (types.length - 1))]
    var duration = 10
    data.push({
      name: typeItem.name,
      value: [index, baseTime], // 前两个维度要有对应XY轴，可扩展
      itemStyle: {
        normal: {
          color: typeItem.color
        }
      }
    })
    baseTime += duration
  }
})
function renderItem(params, api) {
  var categoryIndex = api.value(0) // 取出给定维度的数值
  var start = api.coord([api.value(1), categoryIndex]) // 将数据值转换成坐标系的坐标
  var height = api.size([0, 1])[1] * 0.6 // api.size([0, 1]) 返回一个数组，其中包含两个元素：第一个是计算后的宽度（在这个例子中是 0px，因为我们指定了宽度为0%），第二个是计算后的高度。通过使用 [1]，我们从这个数组中取出第二个元素，即容器的高度（相对于父容器）
  var rectShape = echarts.graphic.clipRectByRect(
    // 输入两个矩形，返回第二个矩形截取第一个矩形的结果。
    {
      x: start[0],
      y: start[1] - height / 2,
      width: 40,
      height: height
    },
    {
      x: params.coordSys.x, // rect的x
      y: params.coordSys.y, // rect的y
      width: params.coordSys.width, // rect的width
      height: params.coordSys.height // rect的height
    }
  )
  return (
    rectShape && {
      type: 'rect',
      transition: ['shape'],
      shape: rectShape,
      style: api.style()
    }
  )
}
option = {
  tooltip: {
    formatter: function (params) {
      return params.marker + params.name
    }
  },
  title: {
    text: 'Profile',
    left: 'center'
  },
  dataZoom: [
    {
      type: 'slider',
      filterMode: 'weakFilter',
      showDataShadow: true,
      top: 400,
      labelFormatter: ''
    },
    {
      type: 'inside',
      filterMode: 'weakFilter'
    }
  ],
  grid: {
    height: 300 // 矩形容器组件的高度
    // show: true
  },
  xAxis: {
    min: startTime,
    splitLine: {
      show: false // 隐藏 X 轴的分割线
    },
    axisLabel: {
      formatter: function (val) {
        return Math.max(0, val - startTime) + ' ms'
      }
    }
  },
  yAxis: {
    data: categories,
    axisLine: {
      show: false
    }
  },
  series: [
    {
      type: 'custom',
      renderItem: renderItem,
      itemStyle: {
        opacity: 0.8
      },
      encode: {
        x: [1, 2],
        y: 0
      },
      data: data
    }
  ]
}
```
