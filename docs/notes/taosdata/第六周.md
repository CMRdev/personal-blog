# 日记

## 复古模式

```js
// 示例数据与规则
var xData = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
var data = [10, 20, 50, 60, 70, 80, 90];
var [dataMin, dataMax] = [0, 100]
// 每个小块的固定像素高度与间隙，块数由数据与柱子像素高度动态计算
var blockHeight = 10; // 每个 rect 的固定高度（像素）
var gap = 2; // rect 之间的间隙（像素）
var baseRule = [{ value: 0, color: '#06b0eeff' }]
// 阈值规则（百分比 -> 颜色），同附件示意
var rules = [
  { value: 20, color: '#007f00' }, // >=20%
  { value: 60, color: '#ff7f00' }, // >=60%
  { value: 80, color: '#7f0000' } // >=80%
];

function getColorByRule(val) {
  let index = rules.findIndex((item) => val / dataMax < item.value / 100)
  if (index === 0) {
    return baseRule[0].color
  } else if (index === -1) {
    return rules[rules.length - 1].color
  } else {
    return rules[index - 1].color
  }
}

var seriesData = data.map((item) => {
  return {
    value: item,
    itemStyle: {
      color: getColorByRule(item),
      opacity: 0.6
    }
  }
})

// option（custom renderItem）
var option = {
  xAxis: [
    {
      type: 'category',
      data: xData,
      axisLine: {
        show: false
      }
    },
    {
      type: 'category',
      position: 'top', // 顶部 X 轴，用于显示标签
      data: data,
      axisLine: { show: false }, // 隐藏轴线
      axisTick: { show: false }, // 隐藏刻度线
      axisLabel: {
        show: true,
        interval: 0,
        formatter: function (value, index) {
          // 根据索引返回对应柱子的数值作为标签
          return value + 'GB';
        },
        fontSize: 16,
        color: function (value) {
          return getColorByRule(value);
        }
      }
    }
  ],
  yAxis: {
    type: 'value',
    min: dataMin,
    max: dataMax,
    show: false
  },
  series: [
    {
      type: 'custom',
      data: seriesData,
      renderItem: function (params, api) {
        var idx = api.value(0); // 类目索引
        var value = api.value(1); // 当前柱子值

        // 底部像素坐标与顶部像素坐标
        var p0 = api.coord([idx, 0]); // 底部
        var p1 = api.coord([idx, dataMax]); // 顶部为 dataMax（背景覆盖整个高度）

        // 类目宽度与柱宽（像素）
        var categoryWidth = api.size([1, 0])[0];
        var barWidth = Math.max(20, categoryWidth - 10);

        // 整根柱子的像素高度（从底到顶 full height 用于背景）
        var totalH = p0[1] - p1[1];
        if (totalH <= 0) return null;
        // 计算当前柱子最多能容纳多少个固定高度的块
        var maxBlocks = Math.floor((totalH + gap) / (blockHeight + gap));
        if (maxBlocks <= 0) return null;

        // 背景：按 rules 渲染整根柱子的每个块（低透明度）
        var children = [];
        for (var j = 0; j < maxBlocks; j++) {
          var topYbg = p0[1] - (j + 1) * (blockHeight + gap) + gap;
          var centerR = (j + 0.5) / maxBlocks; // 相对高度
          var centerValBg = centerR * dataMax;
          children.push({
            type: 'rect',
            shape: {
              x: p0[0] - barWidth / 2,
              y: topYbg,
              width: barWidth,
              height: blockHeight,
              r: 2
            },
            style: {
              fill: getColorByRule(centerValBg),
              opacity: 0.2
            }
          });
        }

        // 高亮：根据 value 填充的块（高不透明）
        var filledBlocks = Math.floor((value / dataMax) * maxBlocks + 1e-6);
        filledBlocks = Math.max(0, Math.min(filledBlocks, maxBlocks));
        for (var i = 0; i < filledBlocks; i++) {
          var topY = p0[1] - (i + 1) * (blockHeight + gap) + gap;
          var centerR2 = (i + 0.5) / maxBlocks;
          var centerVal = centerR2 * dataMax;
          children.push({
            type: 'rect',
            shape: {
              x: p0[0] - barWidth / 2,
              y: topY,
              width: barWidth,
              height: blockHeight,
              r: 2
            },
            style: {
              fill: getColorByRule(centerVal),
              opacity: 0.8
            }
          });
        }

        return {
          type: 'group',
          children: children
        };
      }
    }
  ]
};

```
